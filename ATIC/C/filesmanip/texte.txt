Le programme est constitué d’une boucle de jeu située dans le main, on initialise en premier lieu la position du personnage, la map et les différents éléments nécessaires à l’affichage via la SDL. 
Une variable externe gstatus détermine le statu de jeu,  0 pour en attente, 1 pour menu, 2 pour jeu en cours et 3 pour exit. 
On met en mémoire –avec memset- une structure Input qui contient un tableau de caractères réunissant les touches appuyées, cela permettra par la suite de pouvoir utiliser les diagonales lors du jeu. 
On initialise une liste doublement chainée str_game_Rects contenant la surface à bliter, le rectangle correspondant à l’affichage voulu ainsi que sa couleur. La liste sert à l’affichage, par la suite, du menu. Une tête de liste est définie dans game_InitList, on y rajoute les différents noeuds de str_game_Rects avec la fonction game_AddRects 
Le menu est initialisé dans menu_initMenu, on affiche  les différentes options disponibles en fonction de la taille de la fenêtre et on blit (on copie une image d’une source vers une destination) afin de pouvoir afficher le tout à l’écran.  On initialise la variable gstatus à 1 afin de pouvoir démarrer sur l’écran de menu. 
On redessine le menu avec menu_redrawMenu afin de pouvoir changer la couleur de l’élément sélectionné et redessiné les autres éléments dans leur couleur d’origine. 
Une fois toutes les initialisations des structures relatives au menu réalisées on lance la boucle de jeu.
Si jamais le gstatus est à 1 alors on est en configuration  « menu », on rentre donc dans la gestion de menu.
Tant que l’on ne sélectionne ni la touche echap, ni que le statu quit de l’Input est passé à 1 (vrai), on continue à mettre à jour les évènements en attendant qu’une option soit cliquée. Si jamais l’un des deux cas se produit alors on sort de la boucle en renvoyant 0, la boucle de jeu interprète l’état 0 comme celui devant appeler SDL_Quit qui ferme tous les sous-systèmes de la SDL et libère les ressources allouées à ceux_ci
Une fonction UpdateEvents  vérifie l’état du clavier et grâce à un switch met à jour l’Input et place dans le tableau à la touche correspondante si elle est appuyée ou non. 
On vérifie les valeurs de retour de menu_event, la fonction passe dans les différentes options disponibles dans la liste chainée du menu et appelle menu_redrawMenu à chaque mouvement vers une nouvelle option. 
Si jamais une touche valide est appuyée alors menu_event appelle menu_exec avec la position de l’option choisie, si jamais la position est la dernière alors on nettoie la mémoire avec game_Quit et on sort du programme. Si la position est à 1 alors on passe l’etat du jeu à 2 (pour GAME) et on retourne la valeur de jeu, si la position choisie n’est pas implémentée on retourne 0 afin de ne rien effectuer et de laisser tourner la boucle de menu. 
On retourne dans la boucle de jeu, si la valeur reçue depuis menu est 2 alors on initialise la map avec game_Init, on charge la map avec ChargerMap qui récupére un fichier .txt et l’ouvre. On charge tout d’abord le tileset (fichier image contenant l'ensemble des dessins élémentaires d'un niveau) correspondant à la map avec ChargerMap_tileset (voir syntaxe du fichier lu dans la section 1. a. Aspect graphique) 
On remplit la structure map avec les différentes définitions contenues dans le fichier texte de la map (largeur d’un tile, hauteur d’un tile, nombre de tile dans le tileset, etc…) et notamment TileProp, structure contenant  un rectangle (pour l’affichage) et la définition du tile (si c’est un mur, un tile de fin, un passage de map ou une échelle). 
Une fois toutes les informations au sujet des tiles remplies alors on finit de remplir la structure map avec ChargerMap_Level qui prend en compte la seconde partie du fichier txt (taille de la map, valeur des différentes tiles pour le tableau à deux dimensions Schéma).
On place les valeurs de scrolling à 0, elles seront incrémentées ou décrémentées plus tard en fonction de la direction prise par le personnage. Une fois tous les éléments de la structure Map remplis on peut passer à son affichage avec AfficherMap. 
La fonction va afficher la partie de la map correspondant à la taille de fenêtre définie un peu avant et va prendre en compte une valeur de scrolling afin de pouvoir faire bouger la map en fonction de l’avancement du personnage sur celle-ci. On affiche également le personnage à l’endroit déterminé un peu plus tôt dans le main. L’affichage met à jour la position sur l’écran du rectangle symbolisant le personnage. 
L’initialisation du jeu est donc désormais terminée et on peut donc passer à l’exécution du programme si le gstatus est à 2 (ce qui, si tout s’est bien passé, est toujours le cas à ce niveau). On rentre donc dans game_Exec qui est composé une boucle servant à symboliser un tour de jeu (donc une map complète jusqu’à sa fin).
Tant qu’aucun signal de fin de jeu n’est envoyé on utilise UpdateEvents afin de récupérer les touches appuyées puis on lance la fonction Evolue qui va permettre de déterminer comment le personnage est capable d’avancer. On utilise RecupererVecteur afin de déterminer sur quel axe le personnage va avancer. 
L’un des problèmes que nous avons rencontré avec le déplacement du personnage a été de pouvoir utiliser deux directions en même temps, notamment pour pouvoir effectuer des sauts sur le côté. C’est ici que nous avons dû rajouter à notre programme une structure Input afin de pouvoir gérer plusieurs directions en même temps.

C’est ici que l’on va pouvoir gérer la gravité et les sauts.  Le souci que nous avons eu lors de la programmation de la gravité a été de pouvoir la stopper lorsqu’une échelle était à portée de personnage. Une fonction End calcule tous les éléments en collision avec le personnage et retourne la valeur de l’élément en question, ainsi si jamais le personnage est en contact avec une échelle et que la touché pressée est la flèche du haut, il pourra monter sans soucis. 
Pour les sauts une fonction isGrounded vérifie qu’il y a toujours un tile de type mur en contact avec le bas du personnage. Si jamais c’est le cas alors l’utilisateur peut utiliser la flèche du haut afin d’effectuer un saut. Un compteur, symbolisé par une variable globale tmp, est alors mis en route, tant qu’il n’a pas atteint 0 on bouge le vecteur vy de la valeur courante de -tmp/10 (valeur négative pour pouvoir aller vers le haut de la fenêtre) afin de pouvoir simuler une parabole dans le cas où on appuiera en même temps sur la flèche gauche ou droite.  Tant que le personnage n’a pas de nouveau atteint le sol il ne peut pas sauter de nouveau. 


